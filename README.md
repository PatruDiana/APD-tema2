# APD-tema2
Tema #2 Traffic simulator
// Patru Diana-Georgiana, 332CA

Pentru a putea explica logica rezolvarii fiecarui task in parte si pentru a fi cat mai clean codul, am luat pentru fiecare task variabile aditionale declarate in pachetul utils, in clasa Constants si le-am initilizat/prelucrat in Main / ReaderHandlerFactory / IntersectionHandlerFactory in functie de necesitate.
  * <ins> Task 1: </ins>
    Deoarece la primul task, in input nu se mai citesc date in plus fata de sablonul tuturor fisierelor de intrare, in main am initializat o bariera cu numarul total de masini. In IntersectionHandlerFactory am afisat primul mesaj in care se anunta ca masina a ajuns la semafor, apoi o bariera in care cele n thread-uri se sincronizeaza, urmand ca apoi fiecare masina sa astepte propriul timp citit de la intrare iar la final un nou mesaj catre output in care masina poate sa plece din intersectie.
 * <ins> Task 2: </ins>
    Dupa salvarea numarului de masini ce pot astepta la un semafor si timpul de asteptare pana sa plece, in main am initializat un semafor cu nr de masini citit mai devreme, iar in functia handle(), dupa afisarea mesajului "Car has reached", am pus semaforul unde daca se poate sa intra da acquire si am afisat un nou mesaj urmand sa astepte timpul impus ca mai apoi sa plece si la final sa dea release la semafor pentru a lasa alte masini sa intre in intersectie.
  * <ins> Task 3: </ins>
    Rezolvarea acestui task seamana cu cel precedent doar ca de data aceasta am avut nevoie de un ArrayList de semafoare pentru fiecare linie si initializat cu 1. Astfel, pentru fiecare linie va fi permisa trecerea a fix o masina.
  * <ins> Task 4: </ins>
    In main, am initializat pentru acest task, 2 bariere: una cu numarul total de masini si cealalta cu numarul de linii * numarul de masinii ce pot trece deodata dar si un vector de semafoare pentru fiecare linie initializat cu nr-ul de masini ce pot trece in acelasi timp la un moment dat. Astfel, dupa ce toate masinile se sincronizeaza dupa afisarea primului mesaj prin prima bariera, doar fix Constants.passingCar pot sa treaca semaforul si sa se sincronizeze dupa fiecare mesaj intre ele prin cea de a doua bariera. Dupa iesire din sensul giratoriu, se vor sincroniza si apoi vor da release la semaforul corespunzator pentru linia pe care se afla pentru ca o alta masina sa poata fi selectata.
   * <ins> Task 5: </ins>
    Rezolvarea task-ului 5 seamana cu rezolvarea pentru task-ul 3, fiind nevoie de un ArrayList de semafoare initializat fiecare cu numarul maxim de masini ce pot trece la un moment dat prin sensul giratoriu. Deci, dupa mesajul cu "Car has reached..", se va incerca decrementarea semaforului prin acquire(), iar la final dupa mesajul afisat "Car has exited", se va da release la semafor.
   * <ins> Task 6: </ins>
    Pentru rezolvarea acestui task, am initializat in main un ArrayBlockingQueue cu numarul de masini cu prioritate mica (cazul cel mai extrem fiind cel in care toate masinile au prioritate mica), dar si un AtomicInteger initializat cu 0 ce reprezinta numarul de masini cu prioritate mare deja existente in sensul giratoriu. Astfel, daca o masina are prioritate mai mare decat 1, va incrementa la inceput variabila nrCarsHighEntered, va afisa un mesaj ca a intrat in sensul giratoriu, va astepta 2 secunde si dupa un alt mesaj corespunzator faptului ca a iesit, va decrementa aceeasi variabila atomica. Daca o masina are prioritate mica (= 1), va fi bagata in coada si atata timp cat exista o masina cu prioritate mare deja in intersectie sau nu e randul ei sa intre (id-ul nu este acelasi cu peek-ul cozii), va face wait(50), adica un busy waiting mai eficient putin. Dupa afisarea mesajului ca a iesit din sens (iesirea e instanta), masina va fi scoasa din coada.
   * <ins> Task 7: </ins>
    Am initializat instanta pedestrians prin constructorul deja existent in schelet cu ajutorul variabilelor citite si stocate in clasa Constants, iar pentru a nu se repeta mesajele masinilor (trec pe verde mereu sau stau la rosu), am creat un ArrayList de Atomicuri Boolene. In functia handle() din clasa IntersectionHandlerFactory, totul se intampla cat timp pietonii nu au trecut strada (prin getter-ul isFinished() din clasa Piedestrians). Daca pietonii nu au trecut (asteapta la trecere) inseamna ca masinile pot sa treaca dar fiecare masina va afisa un mesaj corespunzator daca Atomicul Boolean corespunzator inregistrase ultima oara ca masina fusese pe rosu. Aceeasi gandire este si pe else doar ca opus: daca pietonii trec (isPass () == true) si masinile avusesera ultima oara verde, fiecare masina va afisa mesajul "has now red light" doar o singura data. Intrucat, exista posibilitatea ca pietonii sa treaca si masinile sa nu apuce sa printeze, am mai pus la final inca o data if-ul din while.
  * <ins> Task 8: </ins>
    Pentru task-ul cu numarul 8, am avut nevoie de 2 semafoare (unul pentru linia 0 initializat cu numarul de masini ce pot sa treaca la un moment dat deoarece enuntul specifica faptul ca masinile vor pornii de la linia 0, deci ele vor putea da acquire primele la semafor si celalalt semafor initializat cu 0) si 2 bariere: prima initializata cu numarul de masini (pentru sincronizarea masinilor dupa primul mesaj) si a doua cu numarul de masini ce pot sa treaca la un moment dat. Deci, daca directia masinii este pe linia 0, va incerca sa dea un acquire si va putea sa afiseze mesajul cu "has passed the bootleneck" si inainte de a dat release la semaforul de pe linia 1, am asigurat ca toate masinile din linia 0 sa treaca prin cea de a doua bariera. Similar pentru linia 1, se va incerca initial sa se dea acquire la semaforul de pe linia 1, se va afisa mesajul, urmat sa se sincronizeze cu bariera ca mai apoi sa dea release la primul semafor pentru ca urmatoarele masini de pe linia 0 sa intre pe drumul in lucru.
   * <ins> Task 10: </ins>
     In realizarea acestui task, am creat 2 cozi de tip arrayblockinqueue in care vor fi bagate masinile ce au startDirection 0 sau 1. Bariera asigura ca cele n masini se sincronizeaza, urmand ca fiecare masina apoi sa verifice prin busy waiting cat timp coada nu e goala si e randul ei sa plece (peek din coada este egala id-ul masinii), iar in caz afirmativ, se va afisa mesajul corespunzator urmand sa fie scoasa din coada. De mentionat ca atat bagatul/ scosul in coada cat si afisarea de mesaje este facuta prin sincronizarea pe clasa CAR, pentru ca mesajele sa nu se intercaleze.
